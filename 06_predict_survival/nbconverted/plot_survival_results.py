#!/usr/bin/env python
# coding: utf-8

# ## Plot survival prediction results

# In this notebook, we'll compare the results of survival prediction using [elastic net Cox regression](https://scikit-survival.readthedocs.io/en/stable/api/generated/sksurv.linear_model.CoxnetSurvivalAnalysis.html) for expression and methylation data only.
# 
# The files analyzed in this notebook are generated by the `run_survival_prediction.py` script.
# 
# Notebook parameters:
# * SIG_ALPHA (float): significance cutoff for pairwise comparisons (after FDR correction)

# In[1]:


from pathlib import Path

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

import mpmp.config as cfg
import mpmp.utilities.analysis_utilities as au
import mpmp.utilities.survival_utilities as su
import mpmp.utilities.plot_utilities as plu

get_ipython().run_line_magic('load_ext', 'autoreload')
get_ipython().run_line_magic('autoreload', '2')


# In[2]:


SIG_ALPHA = 0.05


# In[3]:


# set results directory
results_dir = Path(cfg.results_dirs['survival'], 'results_1000_top_mad').resolve()

# load results into a single dataframe
results_df = su.load_survival_results(results_dir)
results_df.rename(columns={'identifier': 'cancer_type',
                           'fold_no': 'fold'}, inplace=True)
results_df.head()


# ### Check model convergence results
# 
# In the past we were having issues with model convergence for some cancer types. Let's see how frequently (if at all) this is happening.

# In[4]:


count_df = (results_df[results_df.data_type == 'test']
    .groupby(['cancer_type', 'training_data'])
    .count()
)
problem_df = count_df[count_df['cindex'] != 16].copy()
print(len(problem_df), '/', len(count_df))
problem_df


# This isn't too bad - only 17/98 cancer type/data type combinations are missing a result for a seed or fold.
# 
# We'll just drop those cancer types from our comparisons for now, although we could debug the issues with model convergence sometime in the future.

# In[5]:


drop_cancer_types = problem_df.index.get_level_values(0).unique().values
print(drop_cancer_types)


# ### Plot survival prediction results
# 
# We want to compare survival prediction for:
# * true labels vs. shuffled labels
# * between omics types
#     
# As a metric, for now we're just using the [censored concordance index](https://scikit-survival.readthedocs.io/en/latest/api/generated/sksurv.metrics.concordance_index_censored.html). Essentially, this compares the actual order of events (i.e. death or tumor progression) in the test dataset vs. the order of events predicted by the model in the test samples. A higher concordance index = better prediction.

# In[6]:


sns.set({'figure.figsize': (18, 15)})
fig, axarr = plt.subplots(3, 1)

for ix, data_type in enumerate(
    results_df.training_data.sort_values().unique()
):
    
    ax = axarr[ix]
    
    filtered_df = results_df[
        (results_df.training_data == data_type) &
        (results_df.data_type == 'test')
    ].copy()

    filtered_df.sort_values(by='cancer_type', inplace=True)

    sns.boxplot(data=filtered_df, x='cancer_type', y='cindex', hue='signal',
                hue_order=['signal', 'shuffled'], ax=ax)
    ax.set_xlabel('TCGA cancer type')
    ax.set_ylabel('Concordance index')
    ax.set_title('Survival prediction using {}, top 1000 predictors by MAD'.format(data_type))
    ax.set_ylim(0.0, 1.0)
    
plt.tight_layout()


# In[7]:


results_df['identifier'] = (results_df.cancer_type + '_' +
                            results_df.training_data)
results_df.head()


# In[8]:


compare_df = au.compare_control_ind(results_df,
                                    identifier='identifier',
                                    metric='cindex',
                                    verbose=True)
compare_df['cancer_type'] = compare_df.identifier.str.split('_', 1, expand=True)[0]
compare_df['training_data'] = compare_df.identifier.str.split('_', 1, expand=True)[1]

print(len(compare_df))
compare_df.head()


# In[9]:


sns.set({'figure.figsize': (18, 8)})
    
compare_df.sort_values(by='cancer_type', inplace=True)

sns.boxplot(data=compare_df[~compare_df.cancer_type.isin(drop_cancer_types)],
            x='cancer_type',
            y='delta_cindex',
            hue='training_data',
            hue_order=['expression', 'me_27k', 'me_450k'])
plt.xlabel('TCGA cancer type')
plt.ylabel('cindex(signal) - cindex(shuffled)')
plt.title('Survival prediction, top 1000 predictors by MAD')
plt.ylim(-0.5, 0.5)
    
plt.tight_layout()


# ### Heatmap
# 
# Heatmap

# In[10]:


all_results_df = au.compare_all_data_types(results_df[~results_df.cancer_type.isin(drop_cancer_types)],
                                           SIG_ALPHA,
                                           identifier='cancer_type',
                                           metric='cindex')

all_results_df.rename(columns={'gene': 'cancer_type'}, inplace=True)
all_results_df.sort_values(by='p_value').head(10)


# In[11]:


heatmap_df = (all_results_df
    .pivot(index='training_data', columns='cancer_type', values='delta_mean')
    .reindex(['expression', 'me_27k', 'me_450k'])
)
heatmap_df.iloc[:, :5]


# In[12]:


raw_results_df = (results_df
    .drop(columns=['identifier'])
    .rename(columns={'cancer_type': 'identifier'})
)
raw_results_df.head()


# In[13]:


sns.set({'figure.figsize': (28, 6)})
sns.set_context('notebook', font_scale=1.5)

ax = plu.plot_heatmap(heatmap_df,
                      all_results_df.reset_index(drop=True),
                      different_from_best=True,
                      raw_results_df=raw_results_df,
                      metric='cindex',
                      id_name='cancer_type')

plt.title('Performance by cancer type for survival prediction, expression vs. methylation', pad=15)

